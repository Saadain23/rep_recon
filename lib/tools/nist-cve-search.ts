import { DynamicStructuredTool } from "@langchain/core/tools"
import { z } from "zod"

interface CVEData {
  id: string
  descriptions: Array<{
    lang: string
    value: string
  }>
  published: string
  lastModified: string
}

interface CVEMetrics {
  cvssMetricV40?: Array<{
    cvssData: {
      baseScore: number
      baseSeverity: string
    }
    source: string
  }>
  cvssMetricV31?: Array<{
    cvssData: {
      baseScore: number
      baseSeverity: string
    }
    source: string
  }>
  cvssMetricV30?: Array<{
    cvssData: {
      baseScore: number
      baseSeverity: string
    }
    source: string
  }>
  cvssMetricV2?: Array<{
    cvssData: {
      baseScore: number
      baseSeverity: string
    }
    source: string
  }>
}

interface CVEItem {
  cve: CVEData
  metrics?: CVEMetrics
}

interface NISTCVEResponse {
  resultsPerPage: number
  startIndex: number
  totalResults: number
  version: string
  vulnerabilities: Array<CVEItem>
}

export const nistCveSearchTool = new DynamicStructuredTool({
  name: "nist_cve_search",
  description: `Searches the NIST National Vulnerability Database (NVD) for Common Vulnerabilities and Exposures (CVEs) related to a software product, vendor, or keyword. Returns CVE IDs, descriptions, CVSS scores, severity levels, and publication dates. Use this to find security vulnerabilities for a specific software product or vendor.`,
  schema: z.object({
    keyword: z.string().describe("The software product name, vendor name, or keyword to search for CVEs (e.g., 'Microsoft Exchange', 'Apache', 'OpenSSL')"),
    resultsPerPage: z.number().min(1).max(2000).optional().default(20).describe("Number of results to return per page (max 2000)"),
  }),
  func: async ({ keyword, resultsPerPage = 20 }) => {
    try {
      const apiKey = process.env.NIST_API_KEY
      const baseUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0"
      
      // Build query parameters - don't restrict by date to get all CVEs
      const params = new URLSearchParams({
        keywordSearch: keyword,
        resultsPerPage: resultsPerPage.toString(),
      })

      const headers: HeadersInit = {
        "Accept": "application/json",
      }
      
      if (apiKey) {
        headers["apiKey"] = apiKey
      }

      const url = `${baseUrl}?${params.toString()}`
      console.log(`[NIST CVE Search] Fetching: ${url}`)
      
      const response = await fetch(url, { headers })

      if (!response.ok) {
        const errorText = await response.text()
        console.error(`[NIST CVE Search] API Error: ${response.status} ${response.statusText}`, errorText)
        if (response.status === 429) {
          throw new Error("NIST API rate limit exceeded. Please wait before making more requests.")
        }
        throw new Error(`NIST API error: ${response.status} ${response.statusText}`)
      }

      const data: NISTCVEResponse = await response.json()
      console.log(`[NIST CVE Search] Response: totalResults=${data.totalResults}, vulnerabilities.length=${data.vulnerabilities?.length || 0}`)

      // Check if we have vulnerabilities in the response
      if (!data.vulnerabilities || data.vulnerabilities.length === 0) {
        console.log(`[NIST CVE Search] No vulnerabilities found. Response structure:`, JSON.stringify(data, null, 2).substring(0, 500))
        return JSON.stringify({
          totalResults: data.totalResults || 0,
          resultsPerPage: data.resultsPerPage || 0,
          startIndex: data.startIndex || 0,
          cves: [],
          summary: `Found ${data.totalResults || 0} total CVEs matching "${keyword}". No vulnerabilities in response.`,
          rawResponse: JSON.stringify(data).substring(0, 1000), // Include raw response for debugging
        }, null, 2)
      }

      // Transform the response into a more readable format
      const cves = data.vulnerabilities.map((vuln) => {
        const cveData = vuln.cve
        const description = cveData.descriptions?.find((d: { lang: string; value: string }) => d.lang === "en")?.value || "No description available"
        
        // Get CVSS score (prefer v4.0, then v3.1, then v3.0, then v2.0)
        let cvssScore: number | null = null
        let severity: string | null = null
        let cvssVersion: string | null = null

        if (vuln.metrics?.cvssMetricV40?.[0]) {
          const metric = vuln.metrics.cvssMetricV40[0]
          cvssScore = metric.cvssData.baseScore
          severity = metric.cvssData.baseSeverity
          cvssVersion = "4.0"
        } else if (vuln.metrics?.cvssMetricV31?.[0]) {
          const metric = vuln.metrics.cvssMetricV31[0]
          cvssScore = metric.cvssData.baseScore
          severity = metric.cvssData.baseSeverity
          cvssVersion = "3.1"
        } else if (vuln.metrics?.cvssMetricV30?.[0]) {
          const metric = vuln.metrics.cvssMetricV30[0]
          cvssScore = metric.cvssData.baseScore
          severity = metric.cvssData.baseSeverity
          cvssVersion = "3.0"
        } else if (vuln.metrics?.cvssMetricV2?.[0]) {
          const metric = vuln.metrics.cvssMetricV2[0]
          cvssScore = metric.cvssData.baseScore
          // Map CVSS v2 score to severity
          if (cvssScore >= 7.0) severity = "HIGH"
          else if (cvssScore >= 4.0) severity = "MEDIUM"
          else severity = "LOW"
          cvssVersion = "2.0"
        }

        return {
          cveId: cveData.id,
          description: description.substring(0, 500), // Limit description length
          published: cveData.published,
          lastModified: cveData.lastModified,
          cvssScore,
          severity,
          cvssVersion,
        }
      })

      // Filter to last 2 years for the summary, but return all found CVEs
      const twoYearsAgo = new Date(Date.now() - 2 * 365 * 24 * 60 * 60 * 1000)
      const recentCves = cves.filter(cve => new Date(cve.published) >= twoYearsAgo)
      
      return JSON.stringify({
        totalResults: data.totalResults,
        resultsPerPage: data.resultsPerPage,
        startIndex: data.startIndex,
        cves: cves,
        recentCvesCount: recentCves.length,
        summary: `Found ${data.totalResults} total CVEs matching "${keyword}". Showing ${cves.length} results (${recentCves.length} from last 2 years).`,
      }, null, 2)
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred"
      return JSON.stringify({
        error: errorMessage,
        totalResults: 0,
        cves: [],
      })
    }
  },
})

