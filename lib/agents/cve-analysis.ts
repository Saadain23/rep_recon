import { HumanMessage, AIMessage } from "@langchain/core/messages"
import { createModel } from "../models/llm"
import { AssessmentState } from "../types/assessment-state"
import { CveAnalysisSchema } from "../schemas/cve-analysis"
import { nistCveSearchTool } from "../tools/nist-cve-search"
import { createAgent } from "langchain"

export async function cveAnalysisAgent(state: AssessmentState) {
  const agent = createAgent({
    model: createModel(),
    tools: [nistCveSearchTool],
    systemPrompt: `You are a CVE (Common Vulnerabilities and Exposures) Analysis specialist. Your task is to research and analyze CVE history for software products using the NIST National Vulnerability Database.

Your research should cover:
1. Total number of CVEs (last 2 years)
2. Severity breakdown (Critical, High, Medium, Low) based on CVSS scores
3. Recent critical vulnerabilities (last 6 months) - include CVE ID, description, date, and severity
4. Patch response time average (analyze time between CVE publication and last modification)
5. Trend analysis (improving, stable, declining, or Unknown) based on CVE frequency over time
6. Notable incidents related to CVEs

Use the nist_cve_search tool to search for CVEs related to the product name and vendor. You can perform multiple searches if needed:
- Search by product name
- Search by vendor name
- Combine results to get comprehensive coverage

Analyze the CVSS scores and severity levels from the API response to categorize vulnerabilities. Calculate trends based on the publication dates of CVEs.

Think step by step:
1. What search terms would help me find CVEs for this product?
2. Search using the nist_cve_search tool
3. Analyze the results - count CVEs, categorize by severity, identify recent critical ones
4. Calculate trends and patch response times
5. Once you have sufficient information, provide a comprehensive analysis`,
    responseFormat: CveAnalysisSchema,
  })

  try {
    console.log(`Starting CVE analysis for: ${state.entityResolution?.productName || state.input}`)
    
    const productName = state.entityResolution?.productName || state.input
    const vendorName = state.entityResolution?.vendorName || "Unknown"
    
    const response = await agent.invoke({
      messages: [
        {
          role: "user",
          content: `Analyze the CVE history for: ${productName}
Vendor: ${vendorName}

Research and provide:
1. Total number of CVEs (last 2 years) - use the nist_cve_search tool to find CVEs
2. Severity breakdown (Critical, High, Medium, Low) - categorize based on CVSS scores:
   - Critical: CVSS 9.0-10.0
   - High: CVSS 7.0-8.9
   - Medium: CVSS 4.0-6.9
   - Low: CVSS 0.1-3.9
3. Recent critical vulnerabilities (last 6 months) - include CVE ID, description, date, and severity
4. Patch response time average - analyze time between published date and lastModified date (e.g., "30 days" or "Unknown")
5. Trend analysis (improving, stable, declining, or Unknown) - based on CVE frequency over time
6. Notable incidents related to CVEs
7. Sources - include NIST CVE URLs (format: https://nvd.nist.gov/vuln/detail/{CVE_ID})

Important:
- Use the nist_cve_search tool to fetch actual CVE data from NIST
- Search by both product name and vendor name if needed
- Analyze the CVSS scores and dates from the API response
- sources should include NIST CVE detail URLs for each CVE mentioned
- If no CVE data is available, indicate that clearly with totalCVEs: 0 and trend: "Unknown"`,
        },
      ],
    })

    console.log(`CVE analysis completed for: ${productName}`)

    // Extract structured response from the agent
    const structuredOutput = response.structuredResponse || (response as any).structuredResponse
    
    if (!structuredOutput) {
      // Fallback: try to extract from messages
      const lastMessage = response.messages?.[response.messages.length - 1]
      if (lastMessage && typeof lastMessage.content === "object") {
        const validated = CveAnalysisSchema.safeParse(lastMessage.content)
        if (validated.success) {
          return {
            cveAnalysis: validated.data,
            messages: [lastMessage as AIMessage],
          }
        }
      }
      throw new Error("No structured output received from agent")
    }

    // Validate the structured output matches our schema
    const validated = CveAnalysisSchema.safeParse(structuredOutput)
    
    if (!validated.success) {
      console.error("Structured output validation failed:", validated.error)
      throw new Error("Invalid structured output format")
    }

    // Extract the last message from the agent for context
    const messages = response.messages || []
    const lastMessage = messages[messages.length - 1] || new AIMessage("CVE analysis completed")
    
    return {
      cveAnalysis: validated.data,
      messages: [lastMessage as AIMessage],
    }
    
  } catch (error) {
    console.error("CVE analysis agent execution failed:", error)
    
    // Fallback data structure
    const fallback = {
      totalCVEs: 0,
      severityBreakdown: { critical: 0, high: 0, medium: 0, low: 0 },
      recentCritical: [],
      avgPatchTime: "Unknown",
      trend: "Unknown" as const,
      notableIncidents: [],
      sources: []
    }
    
    return {
      cveAnalysis: fallback,
      messages: [new AIMessage("CVE analysis agent execution failed. Returning fallback data.")],
    }
  }
}

